# Ralph Progress Log
Started: Mon Jan 19 2026

## Codebase Patterns
- Use `COPY --chmod=755` in Dockerfile to set script permissions in a single layer
- Shell scripts use `#!/bin/sh` with `shellcheck shell=dash` directive for POSIX compatibility
- Scripts log to stderr with a prefix like `[scriptname]` for visibility
- Go module: `github.com/mithredate/ai-dev-container`, use `go build ./cmd/bridge` to build
- Go CLI uses standard library `flag` package for argument parsing
- Dockerfile Go version must match go.mod (currently requires Go 1.24+)
- Docker image size ~359MB due to: node:20-alpine (144MB) + docker-cli (31MB) + claude-code (87MB)
- Wrapper scripts go in /scripts/wrappers/ (not /usr/local/bin/) - prepend to PATH for precedence
- Only include wrapper scripts for commands configured in bridge.yaml - node/npm/npx must stay native for Claude Code

---

## 2026-01-19 - US-001
Thread: N/A (first iteration)
- Created `/scripts/entrypoint.sh` wrapper script
- Script uses `exec claude "$@"` to replace shell process with Claude CLI
- Logs startup message to stderr for visibility
- Files changed: `scripts/entrypoint.sh` (new)
- **Learnings for future iterations:**
  - Existing `scripts/bridge` provides good template for shell script style
  - No package.json or Makefile - quality checks limited to shellcheck (not installed locally)
  - Docker daemon not running on host, so image builds can't be tested locally
---

## 2026-01-19 - US-002
Thread: N/A
- Implemented YOLO mode in entrypoint script
- Added CLAUDE_YOLO env var check: when set to "1", runs `claude --dangerously-skip-permissions`
- Updated log messages to indicate which mode is being used (safe mode vs YOLO mode)
- Files changed: `scripts/entrypoint.sh` (modified)
- **Learnings for future iterations:**
  - POSIX shell uses `[ "$VAR" = "1" ]` for string comparison (not `==`)
  - Use `sh -n script.sh` to verify shell script syntax without executing
---

## 2026-01-19 - US-003
Thread: N/A
- Initialized Go module with `go.mod` and `go.sum`
- Created `cmd/bridge/main.go` with CLI skeleton using standard library `flag` package
- Added `gopkg.in/yaml.v3` dependency for future config parsing
- Implemented `--help`, `-h`, `--version`, `-v`, and `--config` flags
- Files changed: `go.mod` (new), `go.sum` (new), `cmd/bridge/main.go` (new)
- **Learnings for future iterations:**
  - Use `go mod tidy` to generate go.sum after adding dependencies
  - Use blank import `_ "gopkg.in/yaml.v3"` to ensure dependency is included in go.mod even if not yet used
  - Custom `flag.Usage` function provides better help formatting than default
---

## 2026-01-19 - US-004
Thread: N/A
- Implemented config parsing in Go bridge with `cmd/bridge/config.go`
- Config struct supports: version, default_container, containers, commands
- Command struct supports: container, exec, workdir
- LoadConfig function: uses BRIDGE_CONFIG env var, falls back to /workspace/.claude/bridge.yaml
- Validation: checks required fields (version="1", commands with container/exec)
- Error handling: clear messages for missing files, invalid YAML (with line numbers), missing fields
- Added ResolveContainer helper for container name mapping
- Files changed: `cmd/bridge/config.go` (new), `cmd/bridge/main.go` (modified)
- **Learnings for future iterations:**
  - yaml.v3 has yaml.TypeError for structured error parsing with line info
  - Use errors.As/errors.Is for error type checking in Go
  - Config validation should be a separate method for reusability
---

## 2026-01-19 - US-005
Thread: N/A
- Implemented path mapping in Go bridge
- Added `Paths` field (map[string]string) to Command struct for path mappings
- Implemented `TranslatePath(path string) string` - translates single path using longest prefix match
- Implemented `TranslateArgs(args []string) []string` - translates all arguments with mapped prefixes
- Path translation is optional (returns unchanged if no paths configured)
- Longest prefix matching ensures nested path mappings work correctly
- Files changed: `cmd/bridge/config.go` (modified)
- **Learnings for future iterations:**
  - Go staticcheck warns about redundant nil checks: `len(nil_map)` returns 0, so `len(m) == 0` covers both nil and empty cases
  - Use longest prefix matching for path translation to handle nested paths correctly
  - Translation functions return original input unchanged when no mappings - allows optional configuration
---

## 2026-01-19 - US-006
Thread: N/A
- Implemented command routing in Go bridge with `runCommand` function
- Routes commands based on config.Commands lookup, falls back to default_container
- Executes via `docker exec -i` with container name resolution
- Supports `workdir` option: adds `-w` flag to docker exec
- Supports `exec` option: maps command alias to actual executable
- Applies path translation to arguments using TranslateArgs
- Proper error handling: unknown commands without default produce clear error
- Exit code propagation from docker exec via exec.ExitError
- Files changed: `cmd/bridge/main.go` (modified)
- **Learnings for future iterations:**
  - Use `os/exec` package for subprocess execution in Go
  - `exec.ExitError` type assertion extracts exit codes from failed commands
  - Connect stdin/stdout/stderr directly to subprocess for real-time streaming
---

## 2026-01-19 - US-007
Thread: N/A
- Implemented real-time output streaming in Go bridge
- Added `golang.org/x/term` dependency for TTY detection
- TTY allocated (-t flag) when both stdin and stdout are terminals
- Real-time streaming already worked via direct os.Stdin/Stdout/Stderr assignment
- Files changed: `cmd/bridge/main.go` (modified), `go.mod` (modified), `go.sum` (modified)
- **Learnings for future iterations:**
  - Use `golang.org/x/term.IsTerminal(int(os.Stdin.Fd()))` to detect terminal
  - Docker exec needs both `-i` (interactive) and `-t` (TTY) for full terminal experience
  - Go's os.Stdout/Stderr are unbuffered - direct assignment provides real-time streaming
---

## 2026-01-19 - US-008
Thread: N/A
- Verified exit code propagation implementation (was completed in US-006)
- Exit code behavior verified:
  - `--help` and `--version` return exit code 0
  - Missing command returns exit code 1
  - Missing/invalid config returns exit code 1
  - exec.ExitError extracts and returns docker exec exit codes
- Quality checks passed: `go build` and `go vet`
- No code changes needed - all acceptance criteria already satisfied
- Files changed: None (verification only)
- **Learnings for future iterations:**
  - Exit code handling via exec.ExitError was implemented alongside command routing in US-006
  - Build artifacts (bridge binary) in root should be gitignored - current pattern `./bridge` may need updating to `bridge`
---

## 2026-01-19 - US-009
Thread: N/A
- Updated Dockerfile for Go multi-stage build
- Replaced node:20-alpine builder stage with golang:1.22-alpine for Go compilation
- Bridge compiled with CGO_ENABLED=0 and -ldflags="-s -w" for static, stripped binary
- Go bridge binary copied to /usr/local/bin/bridge in runtime stage
- Removed yq binary download (no longer needed - replaced by gopkg.in/yaml.v3 in Go)
- Removed wget from builder stage (was only used for yq download)
- Deleted scripts/bridge shell script (replaced by Go binary)
- Added ENTRYPOINT ["/scripts/entrypoint.sh"] for auto-start Claude
- Removed CMD ["sh"] - entrypoint handles startup
- Updated multi-stage comment to reflect Go builder instead of yq
- Files changed: `Dockerfile` (modified), `scripts/bridge` (deleted)
- **Learnings for future iterations:**
  - CGO_ENABLED=0 creates fully static Go binaries that work in Alpine without glibc
  - -ldflags="-s -w" strips debug info and DWARF symbols, reducing binary size
  - Multi-stage builds keep final image small by excluding Go compiler (~400MB)
  - Docker build not tested locally - no Docker daemon on this host
---

## 2026-01-19 - US-010
Thread: N/A
- Fixed Dockerfile bug: golang:1.22-alpine → golang:1.24-alpine (go.mod requires 1.24.0)
- Docker build now succeeds
- Verified image size: 359MB (under 400MB target)
- Layer breakdown:
  - node:20-alpine base: ~144MB (Node.js 101MB + npm/yarn)
  - docker-cli: ~31MB
  - claude-code: ~87MB
  - Go bridge binary: ~2.5MB (only thing we control)
- Verified: yq is NOT present in final image
- Quality checks pass: `go build ./cmd/bridge`, `go vet ./...`
- Files changed: `Dockerfile` (modified - Go version fix)
- **Learnings for future iterations:**
  - Always verify Dockerfile base image versions match go.mod requirements
  - Image size targets should account for base dependency sizes before setting goals
  - Use `docker history --no-trunc` to analyze layer sizes
---

## 2026-01-19 - US-011
Thread: N/A
- Updated examples/claude-bridge.yaml with comprehensive path mapping documentation
- Added 'paths' field documentation to command schema description
- Added Path Mapping section explaining when and why path mappings are needed
- Added paths configuration to PHP commands: /workspace → /var/www/html
- Added paths configuration to Node.js commands: /workspace → /app
- Added usage examples section showing path translation in action
- Files changed: `examples/claude-bridge.yaml` (modified)
- **Learnings for future iterations:**
  - YAML examples are documentation - include clear comments explaining the "why" not just the "how"
  - Show multiple container types (PHP, Node) to demonstrate the pattern applies broadly
  - Include concrete examples of path translation to make the feature understandable
---

## 2026-01-19 - US-012
Thread: N/A
- Created compose.yaml with Docker Compose v2 configuration
- Added two services:
  - claude: Main Claude Code container (built from local Dockerfile)
  - golang: Go sidecar container (golang:1.24-alpine) for running go commands
- Created .claude/bridge.yaml configuration for routing go commands to golang container
- Volume mounts configured:
  - Current directory → /workspace
  - ~/.claude → /home/claude/.claude (session persistence)
  - Docker socket for bridge communication
- Files changed: `compose.yaml` (new), `.claude/bridge.yaml` (new)
- **Learnings for future iterations:**
  - Use `sleep infinity` as command for sidecar containers to keep them running
  - BRIDGE_CONFIG env var points bridge to the config file location
  - Container names in compose.yaml must match the containers section in bridge.yaml
---

## 2026-01-19 - US-014
Thread: N/A
- Added socket-proxy service using tecnativa/docker-socket-proxy to compose.yaml
- Configured socket-proxy with minimal permissions:
  - CONTAINERS=1, EXEC=1, POST=1 (required for docker exec)
  - All other Docker API endpoints disabled (IMAGES=0, NETWORKS=0, etc.)
- Docker socket mounted read-only to socket-proxy only (not to claude container)
- Updated claude service:
  - Changed DOCKER_HOST from unix socket to tcp://socket-proxy:2375
  - Removed direct docker.sock volume mount
  - Added depends_on socket-proxy
- Files changed: `compose.yaml` (modified)
- **Learnings for future iterations:**
  - tecnativa/docker-socket-proxy uses port 2375 for TCP Docker API
  - Socket should be mounted read-only (:ro) to the proxy for security
  - CONTAINERS=1 enables container inspection, EXEC=1 enables exec, POST=1 enables write operations
---

## 2026-01-19 - US-015
Thread: N/A
- Created wrapper scripts in scripts/wrappers/ for 7 commands: go, gofmt, php, composer, node, npm, npx
- Each wrapper follows the BRIDGE_ENABLED pattern:
  - If BRIDGE_ENABLED=1: exec bridge <command> "$@"
  - If not set: fall back to local binary using known paths
- Passthrough mode searches /usr/local/bin and /usr/bin for the real binary
- Scripts use POSIX sh with shellcheck shell=dash directive
- All scripts set to executable (chmod +x)
- Quality checks pass: sh -n (syntax), go build, go vet
- Files changed: `scripts/wrappers/go` (new), `scripts/wrappers/gofmt` (new), `scripts/wrappers/php` (new), `scripts/wrappers/composer` (new), `scripts/wrappers/node` (new), `scripts/wrappers/npm` (new), `scripts/wrappers/npx` (new)
- **Learnings for future iterations:**
  - Wrapper scripts use exit code 127 when command not found (standard shell convention)
  - Passthrough searches specific paths rather than relying on PATH to avoid infinite recursion
  - Using `command -v` to get wrapper's own path allows comparing against real binary paths
---

## 2026-01-19 - US-016
Thread: N/A
- Updated Dockerfile to include wrapper scripts in the final image
- Initial attempt: copied wrappers to /usr/local/bin/ - failed because it overwrote real node binary
- Fixed: copied wrappers to /scripts/wrappers/ directory instead
- Added `ENV PATH="/scripts/wrappers:$PATH"` to prepend wrappers directory to PATH
- Verified passthrough mode works: `node --version`, `npm --version`, `npx --version` all return correct versions
- Docker build completes successfully
- Quality checks pass: go build, go vet
- Files changed: `Dockerfile` (modified)
- **Learnings for future iterations:**
  - Don't copy wrapper scripts to /usr/local/bin/ in node:20-alpine - real node/npm/npx binaries live there
  - Use separate directory (/scripts/wrappers/) and prepend to PATH for wrapper precedence
  - Always test passthrough mode when adding wrapper scripts to verify they don't break local binaries
---

## 2026-01-19 - US-017
Thread: N/A
- Verified existing configuration already had correct container name mapping (ai-dev-container-golang)
- Verified command keys (go, gofmt) already match wrapper script names
- Added BRIDGE_ENABLED=1 environment variable to claude service in compose.yaml
- This enables wrapper scripts to route commands to sidecar containers instead of passthrough mode
- Quality checks pass: go build, go vet
- Files changed: `compose.yaml` (modified)
- **Learnings for future iterations:**
  - BRIDGE_ENABLED=1 is the switch that activates wrapper routing - without it, wrappers fall back to local binaries
  - Verify existing state before making changes - some acceptance criteria may already be satisfied
---

## 2026-01-19 - US-018
Thread: N/A
- Updated README.md documentation with all new features
- Quick Start section: changed to `docker compose up claude` (auto-start via entrypoint)
- Added stdin_open and tty to Quick Start example for interactive sessions
- Added BRIDGE_ENABLED=1 to Quick Start example
- Added paths field to Command Entry Fields table
- Added new "Command Key Naming Convention" section with wrapper script mapping table
- Added new "BRIDGE_ENABLED Environment Variable" section explaining passthrough vs bridge mode
- Building section: replaced yq YAML parser with Go multi-stage build documentation
- Quality checks pass: go build, go vet
- Files changed: `README.md` (modified)
- **Learnings for future iterations:**
  - YOLO mode section already existed and was adequate - check for existing documentation before adding
  - README updates are straightforward text changes - no complex logic involved
---

## 2026-01-19 - US-019
Thread: N/A
- Verified end-to-end setup works with docker compose
- Fixed critical bug: Dockerfile was copying ALL wrapper scripts including node/npm/npx
  - This broke Claude Code because it's a Node.js app that needs native node/npm
  - Solution: Only copy go/gofmt wrappers (commands actually configured in bridge.yaml)
- Test results:
  - `docker compose up -d` starts all services (claude, golang, socket-proxy)
  - `bridge go version` returns Go 1.24.12 from golang container
  - `go version` (via wrapper) returns same Go version
  - File creation in /workspace syncs to host filesystem
  - `docker compose down` cleanly stops all services
- Quality checks pass: go build, go vet
- Files changed: `Dockerfile` (modified)
- **Learnings for future iterations:**
  - BRIDGE_ENABLED=1 routes ALL wrapper commands through bridge - only include wrappers for configured commands
  - Node-based CLI tools (like Claude Code) need native node/npm/npx - never wrap these in the base image
  - Test docker compose services interactively before marking verification stories as complete
---

