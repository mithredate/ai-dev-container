# Ralph Progress Log
Started: Mon Jan 19 2026

## Codebase Patterns
- Use `COPY --chmod=755` in Dockerfile to set script permissions in a single layer
- Shell scripts use `#!/bin/sh` with `shellcheck shell=dash` directive for POSIX compatibility
- Scripts log to stderr with a prefix like `[scriptname]` for visibility
- Go module: `github.com/mithredate/ai-dev-container`, use `go build ./cmd/bridge` to build
- Go CLI uses standard library `flag` package for argument parsing

---

## 2026-01-19 - US-001
Thread: N/A (first iteration)
- Created `/scripts/entrypoint.sh` wrapper script
- Script uses `exec claude "$@"` to replace shell process with Claude CLI
- Logs startup message to stderr for visibility
- Files changed: `scripts/entrypoint.sh` (new)
- **Learnings for future iterations:**
  - Existing `scripts/bridge` provides good template for shell script style
  - No package.json or Makefile - quality checks limited to shellcheck (not installed locally)
  - Docker daemon not running on host, so image builds can't be tested locally
---

## 2026-01-19 - US-002
Thread: N/A
- Implemented YOLO mode in entrypoint script
- Added CLAUDE_YOLO env var check: when set to "1", runs `claude --dangerously-skip-permissions`
- Updated log messages to indicate which mode is being used (safe mode vs YOLO mode)
- Files changed: `scripts/entrypoint.sh` (modified)
- **Learnings for future iterations:**
  - POSIX shell uses `[ "$VAR" = "1" ]` for string comparison (not `==`)
  - Use `sh -n script.sh` to verify shell script syntax without executing
---

## 2026-01-19 - US-003
Thread: N/A
- Initialized Go module with `go.mod` and `go.sum`
- Created `cmd/bridge/main.go` with CLI skeleton using standard library `flag` package
- Added `gopkg.in/yaml.v3` dependency for future config parsing
- Implemented `--help`, `-h`, `--version`, `-v`, and `--config` flags
- Files changed: `go.mod` (new), `go.sum` (new), `cmd/bridge/main.go` (new)
- **Learnings for future iterations:**
  - Use `go mod tidy` to generate go.sum after adding dependencies
  - Use blank import `_ "gopkg.in/yaml.v3"` to ensure dependency is included in go.mod even if not yet used
  - Custom `flag.Usage` function provides better help formatting than default
---

## 2026-01-19 - US-004
Thread: N/A
- Implemented config parsing in Go bridge with `cmd/bridge/config.go`
- Config struct supports: version, default_container, containers, commands
- Command struct supports: container, exec, workdir
- LoadConfig function: uses BRIDGE_CONFIG env var, falls back to /workspace/.claude/bridge.yaml
- Validation: checks required fields (version="1", commands with container/exec)
- Error handling: clear messages for missing files, invalid YAML (with line numbers), missing fields
- Added ResolveContainer helper for container name mapping
- Files changed: `cmd/bridge/config.go` (new), `cmd/bridge/main.go` (modified)
- **Learnings for future iterations:**
  - yaml.v3 has yaml.TypeError for structured error parsing with line info
  - Use errors.As/errors.Is for error type checking in Go
  - Config validation should be a separate method for reusability
---

## 2026-01-19 - US-005
Thread: N/A
- Implemented path mapping in Go bridge
- Added `Paths` field (map[string]string) to Command struct for path mappings
- Implemented `TranslatePath(path string) string` - translates single path using longest prefix match
- Implemented `TranslateArgs(args []string) []string` - translates all arguments with mapped prefixes
- Path translation is optional (returns unchanged if no paths configured)
- Longest prefix matching ensures nested path mappings work correctly
- Files changed: `cmd/bridge/config.go` (modified)
- **Learnings for future iterations:**
  - Go staticcheck warns about redundant nil checks: `len(nil_map)` returns 0, so `len(m) == 0` covers both nil and empty cases
  - Use longest prefix matching for path translation to handle nested paths correctly
  - Translation functions return original input unchanged when no mappings - allows optional configuration
---

## 2026-01-19 - US-006
Thread: N/A
- Implemented command routing in Go bridge with `runCommand` function
- Routes commands based on config.Commands lookup, falls back to default_container
- Executes via `docker exec -i` with container name resolution
- Supports `workdir` option: adds `-w` flag to docker exec
- Supports `exec` option: maps command alias to actual executable
- Applies path translation to arguments using TranslateArgs
- Proper error handling: unknown commands without default produce clear error
- Exit code propagation from docker exec via exec.ExitError
- Files changed: `cmd/bridge/main.go` (modified)
- **Learnings for future iterations:**
  - Use `os/exec` package for subprocess execution in Go
  - `exec.ExitError` type assertion extracts exit codes from failed commands
  - Connect stdin/stdout/stderr directly to subprocess for real-time streaming
---

